-----
### \######2017-10-14######
* ### 设计一个有getMin/getMax功能的栈  
	* 【问题描述】  
		实现一个特殊的栈，	其基本操作pop、push的时间复杂度为O(1)，同时还具有一个时间复杂度也为O(1)的操作，该操作能够返回栈中目前最小/大元素。  
	* 【实现思路】  
		设计采用两个普通的栈，一个栈和正常的栈的基本操作没有区别（记为栈1），另一个栈则用来实时保存前者栈的最小值元素（记为栈2）。例如：有数据**6,2,3,8,4,2** 实现入栈操作：先判断栈2是否为空或者栈2的栈顶元素大于当前要入栈的元素，则把该元素同时入栈到两个栈中，否则就只入栈到栈1。因此对于元素6，栈2为空，则栈1和2都把6入栈；对于元素2，因为栈2的栈顶元素6大于要入栈的元素2，则栈1和栈2都把2入栈...,所有数据入栈完后，栈1的元素为6,2,3,8,4,2栈2的元素为6,2,2。实现出栈操作：对栈1的元素实现普通出栈操作，同时判断出栈的该元素与栈2的栈顶元素是否相等，若相等则栈2的栈顶元素也出栈操作，否则不进行出栈。先将栈1的栈顶元素2出栈，因为栈2的栈顶元素与2相等，所以栈2的栈顶元素2也出栈。返回栈中目前最小的元素操作：如果栈2不为空则直接返回栈顶元素即为目前栈的最小元素。  

* ### 由两个栈组成的队列  
	* 【问题描述】  
		用两个栈实现一个队列，支持队列的基本操作（入队enqueue、出队dequeue)  
	* 【实现思路】  
		一个栈作为压入栈（栈1），入队是只在这个栈将数据压入，另一个栈作为弹出栈（栈2），出队时只从这个栈出队。入队操作：完成栈1的入栈即可。出队操作：当栈2为空且栈1不为空时，将栈1的元素依次出栈然后在入栈到栈2（将栈1的元素倒入栈2），直到栈1中没有元素为止，然后将栈2的栈顶元素作为出队元素，若栈2不为空则直接栈2出栈即可。注意以下两点：1.栈1要往栈2倒入数据，必须全部倒入。2.如果栈2不为空，栈1就不能向栈2倒入数据。

