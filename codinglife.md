-----
### \######2017-10-14######
* ### 设计一个有getMin/getMax功能的栈  
	* 【问题描述】  
		实现一个特殊的栈，	其基本操作pop、push的时间复杂度为O(1)，同时还具有一个时间复杂度也为O(1)的操作，该操作能够返回栈中目前最小/大元素。  
	* 【实现思路】  
		设计采用两个普通的栈，一个栈和正常的栈的基本操作没有区别（记为栈1），另一个栈则用来实时保存前者栈的最小值元素（记为栈2）。例如：有数据**6,2,3,8,4,2** 实现入栈操作：先判断栈2是否为空或者栈2的栈顶元素大于当前要入栈的元素，则把该元素同时入栈到两个栈中，否则就只入栈到栈1。因此对于元素6，栈2为空，则栈1和2都把6入栈；对于元素2，因为栈2的栈顶元素6大于要入栈的元素2，则栈1和栈2都把2入栈...,所有数据入栈完后，栈1的元素为6,2,3,8,4,2栈2的元素为6,2,2。实现出栈操作：对栈1的元素实现普通出栈操作，同时判断出栈的该元素与栈2的栈顶元素是否相等，若相等则栈2的栈顶元素也出栈操作，否则不进行出栈。先将栈1的栈顶元素2出栈，因为栈2的栈顶元素与2相等，所以栈2的栈顶元素2也出栈。返回栈中目前最小的元素操作：如果栈2不为空则直接返回栈顶元素即为目前栈的最小元素。   
  
* ### 由两个栈组成的队列  
	* 【问题描述】  
		用两个栈实现一个队列，支持队列的基本操作（入队enqueue、出队dequeue)  
	* 【实现思路】  
		一个栈作为压入栈（栈1），入队是只在这个栈将数据压入，另一个栈作为弹出栈（栈2），出队时只从这个栈出队。入队操作：完成栈1的入栈即可。出队操作：当栈2为空且栈1不为空时，将栈1的元素依次出栈然后在入栈到栈2（将栈1的元素倒入栈2），直到栈1中没有元素为止，然后将栈2的栈顶元素作为出队元素，若栈2不为空则直接栈2出栈即可。注意以下两点：1.栈1要往栈2倒入数据，必须全部倒入。2.如果栈2不为空，栈1就不能向栈2倒入数据，即只有当栈2为空时，才把栈1的全部元素倒入栈2。  

-----
### \######2017-10-15######
* ### 如何仅用递归函数和栈操作逆序一个栈  
	* 【问题描述】  
		对于一个栈，我们仅仅使用递归函数和栈操作来逆序这个栈的数据，即栈顶到栈底，栈底到栈顶。不能使用其他数据结构包括另外栈结构。  
	* 【实现思路】  
		设计两个递归函数，一个是用于递归返回栈底元素，另一个是结合第一个递归函数递归实现逆序。  
		`递归返回栈底元素:`先返回栈顶元素，判断栈是否为空，若不为空，则递归调用函数本身，再返回栈顶元素，直到栈为空，然后将最后一次返回的栈顶元素进行返回，同时还需要将出该元素之外的其它元素再次依次入栈到栈中。  
![ppt演示](https://github.com/Changzhisong/codinglife/blob/master/3-1.png)  
		```
		public static int getAndRemoveLastElement(Stack <Integer> stack>{
			int result = stack.pop();
			if(stack.isEmpty()) {
				return result;
			} else{
				int last = getAndRemoveLastElement(stack);
				stack.push(result);
				return last;
			}
		}
		```
		`递归逆序:`先判断栈是否为空，若为空直接返回。调用递归返回栈底元素函数，然后在递归调用本身，再次获取栈底元素直到栈为空，此时获取的栈顶元素为原来栈的栈顶元素，然后将元素依次压入栈。  
![ppt演示](https://github.com/Changzhisong/codinglife/blob/master/3-2.png)  
		```
		public static void reverse (Stack <Integer> stack){
			if (stack.isEmpty()){
				return;
			}
			int i = getAndRemoveLastElement(stack);
			reverse(stack);
			stack.push(i);
		}
		```

-----  
### \######2017-11-17######
* ### 猫狗队列  
